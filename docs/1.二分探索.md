# 二分探索

- [二分探索](#二分探索)
  - [はじめに](#はじめに)
  - [二分探索とは](#二分探索とは)
    - [二分探索の実装](#二分探索の実装)
      - [例](#例)
    - [解答例](#解答例)
  - [練習問題](#練習問題)
  - [二分探索の典型問題(答えを二分探索)](#二分探索の典型問題答えを二分探索)
    - [例題 1](#例題-1)
      - [入出力 sample](#入出力-sample)
    - [解法](#解法)
    - [考え方のコツ](#考え方のコツ)
    - [解答例](#解答例-1)
    - [例題 2](#例題-2)
      - [入出力 sample](#入出力-sample-1)
    - [解法](#解法-1)
    - [解答例](#解答例-2)
  - [練習問題](#練習問題-1)
  - [しゃくとり法](#しゃくとり法)
  - [半分全列挙](#半分全列挙)


## はじめに

今回は二分探索について解説します。
二分探索を使った答えを探索するタイプの問題についても解説します。

サンプルコードは Python と Rust で書かれています。

## 二分探索とは

覚えてますか？？
ソートしていなければならない。
ソートするのには O(n log n) かかるので、全探索の方が早い場合もある。

### 二分探索の実装

リストに対して与えられた数字が存在するか二分探索で探してください。存在する場合はそのインデックスを、存在しない場合は-1 を出力してください。

```python
l = list(map(int, input().split()))
search = int(input())
```

#### 例

- 入力 1

```
31
```

- 出力 1
  配列のインデックスは 0 から始まることに注意してください。

```
30
```

- 入力 2

```
100
```

- 出力 2

```
-1
```

### 解答例

<details>
<summary>Python</summary>

```python
l = list(map(int, input().split()))
search = int(input())

left = 0
right = len(l)

while right - left > 1:
	mid = (left + right) // 2
	if l[mid] >= search:
		right = mid
	else:
		left = mid

print(right if l[right] == search else -1)

```

</details>

<details>
<summary>Rust</summary>

```rust
use proconio::input;

fn main() {
    input! {
        n: usize,
        l: [usize; n],
        s: usize
    }

    let mut left = 0usize;
    let mut right = l.len();
    let mut mid;

    while right - left > 1 {
        mid = (right + left) / 2;
        if l[mid] >= s {
            right = mid;
        } else {
            left = mid;
        }
    }

    println!("{}", if l[right] == s { right as isize } else { -1 })
}
```

</details>

## 練習問題

- 解答例を見ずに、自分で書いてみてください。[binary search1](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_k)
- [Atcoder 典型アルゴリズム問題集 A - 二分探索の練習問題](https://atcoder.jp/contests/typical-algorithm/tasks/typical_algorithm_a) を解いてみてください。

基本的な問題です。

- [ABC 077 C - Snuke Festival](https://atcoder.jp/contests/abc077/tasks/arc084_a) を解いてみてください。

この問題は以下のように言い換えられます。
  - 3つのリストA, B, Cがあります。
  - a < b < c となるような (a, b, c) の組み合わせの数を求めてください。
  - ただし、a, b, c はそれぞれ A, B, C から選ばれたものでなければなりません。
制約を見れば、全探索では間に合わないことがわかります。

## 二分探索の典型問題(答えを二分探索)

単調増加関数または単調減少関数によって結果が返ってくるなら、答えを二分探索で探すことができます。
例えば、f(x)が単調増加関数なら、f(x) = y となる x を二分探索で探すことができます。

### 例題 1

[競技プログラミングの鉄則　演習問題集 A12-Printer](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_l)

$N$台のプリンターがあり、 $1$ から $N$ までの番号が付けられています。プリンター $i$ は $A_i$ 秒ごとにチラシを $1$ 枚印刷します。すなわち、スイッチを入れてから $A_i$ 秒後、 $2A_i$ 秒後、 $3A_i$ 秒後･･･に印刷します。すべてのプリンターのスイッチを同時に入れたとき、 $K$ 枚目のチラシが印刷されるのは何秒後でしょうか。

#### 入出力 sample

入力は以下の形式で与えられます

```
N K
A_1 A_2 ... A_N
```

何秒後に $K$ 枚目のチラシが印刷されるかを出力してください。

- 入力 1

```
4 10
1 2 3 4
```

- 出力 1

```
6
```

表にすると、

| 秒数         | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------------ | --- | --- | --- | --- | --- | --- | --- |
| プリンター 1 | ○   | ○   | ○   | ○   | ○   | ○   | ○   |
| プリンター 2 |     | ○   |     | ○   |     | ○   |     |
| プリンター 3 |     |     | ○   |     |     | ○   |     |
| プリンター 4 |     |     |     | ○   |     |     | ○   |

となり、6秒後に10枚目のチラシが印刷されます。

### 解法

x秒後に何枚印刷されているか？を返す関数を作り、xに対して二分探索を行います。

x秒後に何枚印刷されているか？を調べるには、x秒を各プリンターの印刷間隔で割った商の合計を求めれば良いです。

例えば上の例でx=3の場合、

- プリンター1は 3 // 1 = 3 枚印刷
- プリンター2は 3 // 2 = 1 枚印刷
- プリンター3は 3 // 3 = 1 枚印刷

となります(完了した枚数を知りたいので小数点は切り捨てています。)

これは計算量が $O(N)$ となります。

二分探索で $K$ 枚以上になるxの境界を調べます。

### 考え方のコツ

1. ある値xが与えられた時にhogehogeを満たすかどうかを判定する関数を作る。
2. その関数においてngとなるxとokとなるxの境界を求める。

単調性があるかどうかは必ず確かめましょう。(どこかを境界として値が変わるかどうか)

### 解答例

<details>
<summary>Python</summary>

```python
```

</details>

<details>
<summary>Rust</summary>

```rust
```

</details>

### 例題 2

[POJ 2456 Aggressive cows](http://poj.org/problem?id=2456)

N 個の小屋が一直線上に並んでいて、それぞれの座標は $a_0, a_1, \ldots, a_{N-1}$ となっています（ $0 \leq a_0 \leq a_1 \leq \ldots \leq a_{N-1}$ とします）。
このうちの M（$M \leq N$）個を選び、選んだ小屋間の距離をなるべく引き離したいものとします。
"選んだ M 個の小屋のうちの 2 つの小屋の距離の最小値" として考えられる最大値を求めるアルゴリズムを設計してください。
計算量としては $A = a_{N-1}$ として、$O(N \log A)$ を要してもよいものとします。
#### 入出力 sample

入力は以下の形式で与えられます

```
N M
a_0 a_1 ... a_{N-1}
```

- 入力 1

```
5 3
1 2 8 4 9
```

- 出力 1

```
3
```

### 解法

これは答えを探索するタイプの問題です。


- 最大値の最小値をもとめる
- 最小値の最大値をもとめる

がキーワードになることがあります。

方針としては、小屋をx以上離した時にM個の小屋を選べるかどうかを調べ、このxの最大値を二分探索で求めます。

 $M$ 個を選べるかどうかは以下のように調べることができます。
なるべく引き離したいので、最初の小屋は必ず選ぶべきです。
左から順に小屋を見ていき、前の小屋からの距離が $x$ 以上になったら小屋を選びます。これを最後まで続け、選んだ小屋の数が $M$ 以上だったらTrueを返します。

ok = 0, ng = $A$ として、上記がTrueになる最大のxを求めます。

### 解答例

<details>
<summary>Python</summary>

```python
```

</details>

<details>
<summary>Rust</summary>

```rust
```

</details>


## 練習問題

- [競技プログラミングの鉄則　演習問題集 B12-Equation](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_ck)

同じ考え方で解けます。

- [競プロ典型 90 問 001-Yokan Party](https://atcoder.jp/contests/typical90/tasks/typical90_a)

例題 2 の類題です。

- [ARC 050 B 花束](https://atcoder.jp/contests/arc050/tasks/arc050_b)

ちょっと難しいです。x個の花束を作れるか？を判定する関数を作り、二分探索で最大のxを求めます。


## しゃくとり法

## 半分全列挙
