# 二分探索

- [二分探索](#二分探索)
  - [はじめに](#はじめに)
  - [二分探索とは](#二分探索とは)
    - [二分探索の実装](#二分探索の実装)
      - [例](#例)
  - [練習問題1](#練習問題1)
    - [解答例](#解答例)
  - [二分探索の典型問題(答えを二分探索)](#二分探索の典型問題答えを二分探索)
    - [例題 1](#例題-1)
      - [制約](#制約)
      - [入出力 sample](#入出力-sample)
    - [解法](#解法)
    - [解答例](#解答例-1)
  - [考え方のコツ](#考え方のコツ)
    - [例題 2](#例題-2)
      - [入出力 sample](#入出力-sample-1)
    - [解法](#解法-1)
    - [解答例](#解答例-2)
  - [練習問題2](#練習問題2)
    - [解答例](#解答例-3)
  - [課題](#課題)
    - [解答例](#解答例-4)

## はじめに

今回は二分探索について解説します。
二分探索を使って解ける、色々な問題についても解説します。

サンプルコードは Python と Rust で書かれています。

## 二分探索とは

二分探索とは何か？については以下の動画を(必ず)見てください。

- [二分探索とは何か](https://youtu.be/YihRNX_JnuQ?si=T_v7Py16_bjZW93i)

ソートするのには O(n log n) かかるので、全探索の方が早い場合もある。

### 二分探索の実装

リストに対して与えられた数字が存在するか二分探索で探してください。存在する場合はそのインデックスを、存在しない場合は-1 を出力してください。

```python
# pythonでの入力例
l = list(map(int, input().split()))
search = int(input())
```

#### 例

- 入力 1

```
1 2 3 4 5 6 7 8 9 10
5
```

- 出力 1
  配列のインデックスは 0 から始まることに注意してください。

```
4
```

- 入力 2

```
100
```

- 出力 2

```
-1
```

## 練習問題1

1. [binary search1](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_k)

解答例を一瞬見て、理解したら何も見ずに自分で書いてみてください。

2. [Atcoder 典型アルゴリズム問題集 A - 二分探索の練習問題](https://atcoder.jp/contests/typical-algorithm/tasks/typical_algorithm_a) を解いてみてください。

基本的な問題です。

3. [ABC 077 C - Snuke Festival](https://atcoder.jp/contests/abc077/tasks/arc084_a) を解いてみてください。

この問題は以下のように言い換えられます。

- 3 つのリスト A, B, C があります。
- a < b < c となるような (a, b, c) の組み合わせの数を求めてください。
- ただし、a, b, c はそれぞれ A, B, C から選ばれたものでなければなりません。
制約を見れば、全探索では間に合わないことがわかります。

### 解答例

| 問題番号 | Python                                   | Rust                                   | Go                                   | C++                                     | Kotlin                                   |
| -------- | ---------------------------------------- | -------------------------------------- | ------------------------------------ | --------------------------------------- | ---------------------------------------- |
| 1        | [.py](./python/1.binary_search1.py)      | [.rs](./rust/1.binary_search1.rs)      | [.go](./go/1.binary_search1.go)      | [.cpp](./cpp/1.binary_search1.cpp)      | [.kt](./kotlin/1.binary_search1.kt)      |
| 2        | [.py](./python/2.typical_algorithm_a.py) | [.rs](./rust/2.typical_algorithm_a.rs) | [.go](./go/2.typical_algorithm_a.go) | [.cpp](./cpp/2.typical_algorithm_a.cpp) | [.kt](./kotlin/2.typical_algorithm_a.kt) |
| 3        | [.py](./python/3.abc077_c.py)            | [.rs](./rust/3.abc077_c.rs)            | [.go](./go/3.abc077_c.go)            | [.cpp](./cpp/3.abc077_c.cpp)            | [.kt](./kotlin/3.abc077_c.kt)            |

## 二分探索の典型問題(答えを二分探索)

単調増加関数または単調減少関数によって結果が返ってくるなら、答えを二分探索で探すことができます。
例えば、f(x)が単調増加関数なら、f(x) = y となる x を二分探索で探すことができます。

### 例題 1

[競技プログラミングの鉄則　演習問題集 A12-Printer](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_l)

$N$台のプリンターがあり、 $1$ から $N$ までの番号が付けられています。プリンター $i$ は $A_i$ 秒ごとにチラシを $1$ 枚印刷します。すなわち、スイッチを入れてから $A_i$ 秒後、 $2A_i$ 秒後、 $3A_i$ 秒後･･･に印刷します。すべてのプリンターのスイッチを同時に入れたとき、 $K$ 枚目のチラシが印刷されるのは何秒後でしょうか。

#### 制約

$1 \leq N \leq 100000$
$1 \leq K \leq 10$
$1 \leq A_i \leq 10^9$
答えは $10^9$ を超えない
入力はすべて整数

#### 入出力 sample

入力は以下の形式で与えられます

```
N K
A_1 A_2 ... A_N
```

何秒後に $K$ 枚目のチラシが印刷されるかを出力してください。

- 入力 1

```
4 10
1 2 3 4
```

- 出力 1

```
6
```

表にすると、

| 秒数         | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| ------------ | --- | --- | --- | --- | --- | --- | --- |
| プリンター 1 | ○   | ○   | ○   | ○   | ○   | ○   | ○   |
| プリンター 2 |     | ○   |     | ○   |     | ○   |     |
| プリンター 3 |     |     | ○   |     |     | ○   |     |
| プリンター 4 |     |     |     | ○   |     |     | ○   |

となり、6 秒後に 10 枚目のチラシが印刷されます。

### 解法

x 秒後に何枚印刷されているか？を返す関数を作り、x に対して二分探索を行います。

x 秒後に何枚印刷されているか？を調べるには、x 秒を各プリンターの印刷間隔で割った商の合計を求めれば良いです。

例えば上の例で x=3 の場合、

- プリンター 1 は 3 // 1 = 3 枚印刷
- プリンター 2 は 3 // 2 = 1 枚印刷
- プリンター 3 は 3 // 3 = 1 枚印刷

となります(完了した枚数を知りたいので小数点は切り捨てています。)

これは計算量が $O(N)$ となります。

二分探索で $K$ 枚以上になる x の境界を調べます。

表にするとわかりやすいです。

| 枚数 (K)                  | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  |
| ------------------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 印刷にかかる秒数 (x)      | 1   | 2   | 2   | 3   | 3   | 4   | 4   | 4   | 5   | 6   | 6   | 6   | 7   | 7   |
| 10 枚以上印刷されたか？　 | ×   | ×   | ×   | ×   | ×   | ×   | ×   | ×   | ×   | ○   | ○   | ○   | ○   | ○   |

10 枚以上印刷されたか？が ⚪︎ となる最小の x を求めれば良いので、二分探索ができそうです。

### 解答例

問題 4
| Python | Rust | Go | C++ | Kotlin |
| ---------------------------------------- | -------------------------------------- | ------------------------------------ | --------------------------------------- | ---------------------------------------- |
| [.py](./python/4.tessoku_book_l.py) | [.rs](./rust/4.tessoku_book_l.rs) | [.go](./go/4.tessoku_book_l.go) | [.cpp](./cpp/4.tessoku_book_l.cpp) | [.kt](./kotlin/4.tessoku_book_l.kt) |

## 考え方のコツ

1. ある値 x が与えられた時に hogehoge を満たすかどうかを判定する関数を作る。
2. その関数において ng となる x と ok となる x の境界を求める。

単調性があるかどうかは必ず確かめましょう。(どこかを境界として値が変わるかどうか)

例えば、配列から値を探す場合は、「x 以上かどうか？」が配列のある要素から変わるので、単調性があります。

この考え方をもとに、以下の問題を解いてみてください。

### 例題 2

[POJ 2456 Aggressive cows](http://poj.org/problem?id=2456)

N 個の小屋が一直線上に並んでいて、それぞれの座標は $a_0, a_1, \ldots, a_{N-1}$ となっています（ $0 \leq a_0 \leq a_1 \leq \ldots \leq a_{N-1}$ とします）。
このうちの M（$M \leq N$）個を選び、選んだ小屋間の距離をなるべく引き離したいものとします。
"選んだ M 個の小屋のうちの 2 つの小屋の距離の最小値" として考えられる最大値を求めてください。
計算量としては $A = a_{N-1}$ として、$O(N \log A)$ を要してもよいものとします。

#### 入出力 sample

入力は以下の形式で与えられます

```
N M
a_0 a_1 ... a_{N-1}
```

- 入力 1

```
5 3
1 2 4 8 9
```

- 出力 1

```
3
```

例えば 1,2,9 を選ぶと、1 と 2 の距離は 1、2 と 9 の距離は 7 となり、最小値は 1 となります。
今回の場合、1, 4, 8 を選ぶと、1 と 4 の距離は 3、4 と 8 の距離は 4 で、最小値が 3 となり、これが様々な選び方のうちの最大値となります。

### 解法

これは答えを探索するタイプの問題です。

- 最大値の最小値をもとめる
- 最小値の最大値をもとめる

がキーワードになることがあります。

方針としては、小屋を x 以上離した時に M 個の小屋を選べるかどうかを調べ、この x の最大値を二分探索で求めます。

$M$ 個を選べるかどうかは以下のように調べることができます。
なるべく引き離したいので、最初の小屋は必ず選ぶべきです。
左から順に小屋を見ていき、前の小屋からの距離が $x$ 以上になったら小屋を選びます。これを最後まで続け、選んだ小屋の数が $M$ 以上だったら True を返します。

ok = 0, ng = $A$ mid=(ok + ng) // 2 として、上記が True になる最大の x を求めます。

表にしてみましょう。

| 離す距離 (x)         | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| -------------------- | --- | --- | --- | --- | --- | --- | --- | --- |
| 小屋の個数           | 5   | 5   | 3   | 3   | 2   | 1   | 1   | 1   |
| 用意した関数が返す値 | ⚪︎ | ⚪︎ | ⚪︎ | ⚪︎ | ×   | ×   | ×   | ×   |

例えば、x=1 の時は間隔を 1 以上にすれば良いので全ての小屋が選べ、x=4 の時は、1 から間隔を 4 開ける必要があるので 8 を選び、これ以上は選べないので 2 個しか選べません。
これを見ると、true を返す最大の値である x=3 が答えとなります。

### 解答例

問題 5
| Python | Rust | Go | C++ | Kotlin |
| ----------------------------- | ----------------------------- | ----------------------------- | ------------------------------- | ----------------------------- |
| [.py](./python/5.poj2456.py) | [.rs](./rust/5.poj2456.rs) | [.go](./go/5.poj2456.go) | [.cpp](./cpp/5.poj2456.cpp) | [.kt](./kotlin/5.poj2456.kt) |

## 練習問題2

6. [競技プログラミングの鉄則　演習問題集 B12-Equation](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_ck)

同じ考え方で解けます。

7. [競プロ典型 90 問 001-Yokan Party](https://atcoder.jp/contests/typical90/tasks/typical90_a)

例題 2 の類題です。

8. [ARC 050 B 花束](https://atcoder.jp/contests/arc050/tasks/arc050_b)

ちょっと難しいです。x 個の花束を作れるか？を判定する関数を作り、二分探索で最大の x を求めます。

### 解答例

| 問題番号 | Python                               | Rust                               | Go                               | C++                                 | Kotlin                               |
| -------- | ------------------------------------ | ---------------------------------- | -------------------------------- | ----------------------------------- | ------------------------------------ |
| 6        | [.py](./python/6.tessoku_book_ck.py) | [.rs](./rust/6.tessoku_book_ck.rs) | [.go](./go/6.tessoku_book_ck.go) | [.cpp](./cpp/6.tessoku_book_ck.cpp) | [.kt](./kotlin/6.tessoku_book_ck.kt) |
| 7        | [.py](./python/7.typical90_a.py)     | [.rs](./rust/7.typical90_a.rs)     | [.go](./go/7.typical90_a.go)     | [.cpp](./cpp/7.typical90_a.cpp)     | [.kt](./kotlin/7.typical90_a.kt)     |
| 8        | [.py](./python/8.arc050_b.py)        | [.rs](./rust/8.arc050_b.rs)        | [.go](./go/8.arc050_b.go)        | [.cpp](./cpp/8.arc050_b.cpp)        | [.kt](./kotlin/8.arc050_b.kt)        |

## 課題

9. [Binary Search](https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_4_B&lang=ja)

基本的な問題です

10. [ABC 023 D 射撃王](https://atcoder.jp/contests/abc023/tasks/abc023_d)

チャレンジしてみよう。

11. [JOI 2009 本戦 B ピザ](https://atcoder.jp/contests/joi2009ho/tasks/joi2009ho_b)

チャレンジしてみよう。

### 解答例

| 問題番号 | Python                            | Rust                            | Go                            | C++                              | Kotlin                            |
| -------- | --------------------------------- | ------------------------------- | ----------------------------- | -------------------------------- | --------------------------------- |
| 9        | [.py](./python/9.alds1_4_b.py)    | [.rs](./rust/9.alds1_4_b.rs)    | [.go](./go/9.alds1_4_b.go)    | [.cpp](./cpp/9.alds1_4_b.cpp)    | [.kt](./kotlin/9.alds1_4_b.kt)    |
| 10       | [.py](./python/10.abc023_d.py)    | [.rs](./rust/10.abc023_d.rs)    | [.go](./go/10.abc023_d.go)    | [.cpp](./cpp/10.abc023_d.cpp)    | [.kt](./kotlin/10.abc023_d.kt)    |
| 11       | [.py](./python/11.joi2009ho_b.py) | [.rs](./rust/11.joi2009ho_b.rs) | [.go](./go/11.joi2009ho_b.go) | [.cpp](./cpp/11.joi2009ho_b.cpp) | [.kt](./kotlin/11.joi2009ho_b.kt) |
